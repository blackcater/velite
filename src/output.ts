import { copyFile, writeFile } from 'node:fs/promises'
import { join, relative } from 'node:path'
import pascalcase from 'pascalcase'

import { logger } from './logger'
import type { Collections } from './types'

const emitted = new Map<string, string>()

/**
 * emit file if content changed, reduce disk IO and improve fast refresh in app
 * @param path file path
 * @param content file data
 * @param log log message
 */
export async function emit(path: string, content: string, log?: string): Promise<void> {
  if (emitted.get(path) === content) {
    logger.log(`skipped write '${path}' with same content`)
    return
  }
  await writeFile(path, content)
  logger.log(log ?? `wrote '${path}' with ${content.length} bytes`)
  emitted.set(path, content)
}

/**
 * output entry file
 * @param dest output destination directory
 * @param configPath resolved config file path
 * @param collections collection options
 */
export async function outputEntry(dest: string, configPath: string, collections: Collections): Promise<void> {
  const begin = performance.now()

  // generate entry according to `config.collections`
  const configModPath = relative(dest, configPath)
    .replace(/\\/g, '/') // replace windows path separator
    .replace(/\.[mc]?[jt]s$/i, '') // remove extension

  const entry: string[] = []
  const dts: string[] = [`import config from '${configModPath}'\n`]

  // eslint-disable-next-line array-callback-return
  Object.entries(collections).map(([name, collection]) => {
    const collectionTypeName = pascalcase(collection.name)
    entry.push(`export { default as ${name} } from './${name}.json'`)
    dts.push(`export type ${collectionTypeName} = NonNullable<typeof config.collections>['${name}']['schema']['_output']`)
    dts.push(`export declare const ${name}: ${collectionTypeName + (collection.single ? '' : '[]')}\n`)
  })

  const banner = '// This file is generated by Velite\n\n'

  const entryFile = join(dest, 'index.js')
  await emit(entryFile, banner + entry.join('\n'), `created entry file in '${entryFile}'`)

  const dtsFile = join(dest, 'index.d.ts')
  await emit(dtsFile, banner + dts.join('\n'), `created entry dts file in '${dtsFile}'`)

  logger.info(`output entry file in '${dest}'`, begin)
}

/**
 * output all built result
 * @param dest output destination directory
 * @param result all built result
 */
export async function outputData(dest: string, result: Record<string, any>): Promise<void> {
  const begin = performance.now()
  const logs: string[] = []
  await Promise.all(
    Object.entries(result).map(async ([name, data]) => {
      if (data == null)
        return
      const target = join(dest, `${name}.json`)
      // TODO: output each record separately to a single file to improve fast refresh performance in app
      await emit(target, JSON.stringify(data, null, 2), `wrote '${target}' with ${data.length ?? 1} ${name}`)
      logs.push(`${data.length ?? 1} ${name}`)
    }),
  )
  logger.info(`output ${logs.join(', ')}`, begin)
}

/**
 * output all collected assets
 * @param dest output destination directory
 * @param assets all collected assets
 */
export async function outputAssets(dest: string, assets: Map<string, string>): Promise<void> {
  const begin = performance.now()
  let count = 0
  await Promise.all(
    Array.from(assets.entries()).map(async ([name, from]) => {
      if (emitted.get(name) === from) {
        logger.log(`skipped copy '${name}' with same content`)
        return
      }
      await copyFile(from, join(dest, name))
      // logger.log(`copied '${name}' from '${from}'`)
      emitted.set(name, from)
      count++
    }),
  )
  logger.info(`output ${count} assets`, begin)
}
